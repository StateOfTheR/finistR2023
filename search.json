[
  {
    "objectID": "R_INLA.html",
    "href": "R_INLA.html",
    "title": "R INLA",
    "section": "",
    "text": "Présentation de la méthodologie INLA (integrated nested Laplace approximation) en utilisant les packages {INLA} et sa surcouche {inlabru}.\nL’approximation de Laplace intégrée et imbriquée (INLA) est une approche de l’inférence statistique pour les modèles de champs aléatoires gaussiens latents (GMRF) introduite par Rue et Martino (2006). Elle fournit une alternative rapide et déterministe au MCMC qui était l’outil standard pour l’inférence de tels modèles. Le principal avantage de l’approche INLA par rapport à la MCMC est qu’elle est beaucoup plus rapide à calculer.\n{inlabru} est une surcouche du package INLA, qui facilite l’utilisation du package R {INLA} en simplifiant la syntaxe. Ce package intègre deux extensions : - Modèles de type GAM (pour intégrer des prédicteurs non linéaires) - Processus de Cox log-Gaussien pour modéliser des processus univariés et spatiaux basés sur des données de comptages.\nSources :\n\nhttps://www.r-inla.org/home\nhttps://inla.r-inla-download.org/r-inla.org/doc/inla-manual/inla-manual.pdf\nhttps://sites.google.com/inlabru.org/inlabru/home\nhttps://inlabru-org.github.io/inlabru/index.html"
  },
  {
    "objectID": "R_INLA.html#installation-de-inla",
    "href": "R_INLA.html#installation-de-inla",
    "title": "R INLA",
    "section": "Installation de INLA",
    "text": "Installation de INLA\n\n# Base de R INLA\ninstall.packages(\"INLA\",repos=c(getOption(\"repos\"),INLA=\"https://inla.r-inla-download.org/R/stable\"), dep=TRUE)\n# inlabru wrapper\ninstall.packages(\"inlabru\")"
  },
  {
    "objectID": "R_INLA.html#utilisation",
    "href": "R_INLA.html#utilisation",
    "title": "R INLA",
    "section": "Utilisation",
    "text": "Utilisation\n\nExemple 1\n\nSetup\n\n# Chargement des packages\nlibrary(INLA)\nlibrary(inlabru)\nlibrary(INLA)\nlibrary(lme4) # pour comparer avec l'approche frequentiste \nlibrary(ggplot2)\nlibrary(ggpolypath)\nlibrary(RColorBrewer)\nlibrary(geoR)\nlibrary(tidyverse)\n\nLe dataset awards contient le nombre de réussites (num_awards) en math (math) pour une classe de 200 élèves. La réponse mesurée étant un comptage, nous devons spécifier un modèle généralisé avec fonction de lien Poisson.\n\n# Chargement des donnees\nload(\"data/awards.RData\")\nhead(awards)\n\n  num_awards       prog math id\n1          0 Vocational   41  1\n2          0    General   41  2\n3          0 Vocational   44  3\n4          0 Vocational   42  4\n5          0 Vocational   40  5\n6          0    General   42  6\n\n\nLa fonction bru_options_set permet de fixer des options sur des paramètres spécifiques à INLA.\n\nbru_options_set(bru_verbose = TRUE,\n                control.compute = list(dic = TRUE, waic = TRUE))\n\nOn peut récupérer ces paramètres avec :\n\nbru_options_get()\n\n\n\nApplication\nNous expliquons le nombre de récompenses obtenues en fonction de la note en math suivant le modèle\n\\[Y_i\\overset{ind}{\\sim}\\mathcal{P}(\\exp(\\mu+\\alpha\\cdot x_i))\\,.\\]\n\n# Formulation du modele\ncmp1 <- num_awards ~ math + 1\n# Application de la formule avec un modèle de Poisson\nfit.glm.bru <- bru(cmp1, family = \"poisson\", data = awards)\n\niinla: Iteration 1 [max:1]\n\nsummary(fit.glm.bru)\n\ninlabru version: 2.8.0\nINLA version: 23.04.24\nComponents:\nmath: main = linear(math), group = exchangeable(1L), replicate = iid(1L)\nIntercept: main = linear(1), group = exchangeable(1L), replicate = iid(1L)\nLikelihoods:\n  Family: 'poisson'\n    Data class: 'data.frame'\n    Predictor: num_awards ~ .\nTime used:\n    Pre = 0.817, Running = 0.184, Post = 0.0343, Total = 1.04 \nFixed effects:\n            mean    sd 0.025quant 0.5quant 0.975quant   mode kld\nmath       0.086 0.010      0.067    0.086      0.105  0.086   0\nIntercept -5.349 0.591     -6.508   -5.349     -4.191 -5.349   0\n\nDeviance Information Criterion (DIC) ...............: 384.07\nDeviance Information Criterion (DIC, saturated) ....: 208.02\nEffective number of parameters .....................: 1.99\n\nWatanabe-Akaike information criterion (WAIC) ...: 384.48\nEffective number of parameters .................: 2.35\n\nMarginal log-Likelihood:  -204.02 \n is computed \nPosterior summaries for the linear predictor and the fitted values are computed\n(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')\n\n\n\n\nComparaison avec un GLM\n\ncmp2 <- num_awards ~ math\nfit2.glm <- glm(cmp2, family=\"poisson\", data = awards)\nsummary(fit2.glm)\n\n\nCall:\nglm(formula = cmp2, family = \"poisson\", data = awards)\n\nDeviance Residuals: \n    Min       1Q   Median       3Q      Max  \n-2.1853  -0.9070  -0.6001   0.3246   2.9529  \n\nCoefficients:\n             Estimate Std. Error z value Pr(>|z|)    \n(Intercept) -5.333532   0.591261  -9.021   <2e-16 ***\nmath         0.086166   0.009679   8.902   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for poisson family taken to be 1)\n\n    Null deviance: 287.67  on 199  degrees of freedom\nResidual deviance: 204.02  on 198  degrees of freedom\nAIC: 384.08\n\nNumber of Fisher Scoring iterations: 6\n\n\nLes réponses sont proches.\n\n\nIntégration d’un effet aléatoire\nPour prendre en compte le problème classique de surdispersion dans les données de comptages, il peut être intéressant de rajouter un effet aléatoire de la manière suivante.\n\\[Y_i\\overset{ind}{\\sim}\\mathcal{P}(\\exp(\\mu+\\alpha\\cdot x_i+E_i)) \\quad \\text{avec}\\quad E_i\\overset{ind}{\\sim}\\mathcal{N}(0,\\sigma^2).\\]\n\ncmp3 <- num_awards ~ math + 1 + rand.eff(map = 1:200, model = \"iid\", n = 200)\n\nfit3.glmm.bru <- bru(cmp3, family = \"poisson\", data = awards)\n\nWarning in inlabru:::component.character(\"rand.eff\", map = 1:200, model =\n\"iid\", : Use of 'map' is deprecated and may be disabled; use 'main' instead.\n\n\niinla: Iteration 1 [max:1]\n\nsummary(fit3.glmm.bru)\n\ninlabru version: 2.8.0\nINLA version: 23.04.24\nComponents:\nmath: main = linear(math), group = exchangeable(1L), replicate = iid(1L)\nrand.eff: main = iid(1:200), group = exchangeable(1L), replicate = iid(1L)\nIntercept: main = linear(1), group = exchangeable(1L), replicate = iid(1L)\nLikelihoods:\n  Family: 'poisson'\n    Data class: 'data.frame'\n    Predictor: num_awards ~ .\nTime used:\n    Pre = 0.472, Running = 0.222, Post = 0.0845, Total = 0.778 \nFixed effects:\n            mean    sd 0.025quant 0.5quant 0.975quant   mode kld\nmath       0.086 0.010      0.067    0.086      0.105  0.086   0\nIntercept -5.349 0.591     -6.509   -5.349     -4.190 -5.349   0\n\nRandom effects:\n  Name    Model\n    rand.eff IID model\n\nModel hyperparameters:\n                           mean       sd 0.025quant 0.5quant 0.975quant   mode\nPrecision for rand.eff 19903.65 19900.90     563.99 13861.13   74196.18 187.82\n\nDeviance Information Criterion (DIC) ...............: 384.03\nDeviance Information Criterion (DIC, saturated) ....: 207.97\nEffective number of parameters .....................: 2.00\n\nWatanabe-Akaike information criterion (WAIC) ...: 384.47\nEffective number of parameters .................: 2.38\n\nMarginal log-Likelihood:  -204.09 \n is computed \nPosterior summaries for the linear predictor and the fitted values are computed\n(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')\n\n\n\n\nComparaison avec l’approche fréquentiste\n\ncmp4<- num_awards ~ math + (1|id)\nfit4.glmm<-glmer(cmp4, family = poisson, data = awards)\nsummary(fit4.glmm)\n\nGeneralized linear mixed model fit by maximum likelihood (Laplace\n  Approximation) [glmerMod]\n Family: poisson  ( log )\nFormula: num_awards ~ math + (1 | id)\n   Data: awards\n\n     AIC      BIC   logLik deviance df.resid \n   381.2    391.1   -187.6    375.2      197 \n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-1.1653 -0.5518 -0.3760  0.3900  2.9242 \n\nRandom effects:\n Groups Name        Variance Std.Dev.\n id     (Intercept) 0.3257   0.5707  \nNumber of obs: 200, groups:  id, 200\n\nFixed effects:\n            Estimate Std. Error z value Pr(>|z|)    \n(Intercept) -5.63163    0.70476  -7.991 1.34e-15 ***\nmath         0.08861    0.01161   7.634 2.28e-14 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nCorrelation of Fixed Effects:\n     (Intr)\nmath -0.982\n\n\nOn remarque que les résultats sont un peu moins comparables. Pour se rapprocher de glmer(), on peut modifier la loi a priori sur l’effet aléatoire.\n\ncmp5 <- num_awards ~ math + 1 + rand.eff(map = 1:200, model = \"iid\", n = 200,\n                                                 hyper=list(prec=list(param=c(10,0.1),\n                                                                      prior=\"pc.prec\")))\nfit5.glmm.bru <- bru(cmp5, family = \"poisson\", data = awards )\n\nWarning in inlabru:::component.character(\"rand.eff\", map = 1:200, model =\n\"iid\", : Use of 'map' is deprecated and may be disabled; use 'main' instead.\n\n\niinla: Iteration 1 [max:1]\n\nsummary(fit5.glmm.bru)\n\ninlabru version: 2.8.0\nINLA version: 23.04.24\nComponents:\nmath: main = linear(math), group = exchangeable(1L), replicate = iid(1L)\nrand.eff: main = iid(1:200), group = exchangeable(1L), replicate = iid(1L)\nIntercept: main = linear(1), group = exchangeable(1L), replicate = iid(1L)\nLikelihoods:\n  Family: 'poisson'\n    Data class: 'data.frame'\n    Predictor: num_awards ~ .\nTime used:\n    Pre = 0.453, Running = 0.227, Post = 0.0856, Total = 0.765 \nFixed effects:\n            mean    sd 0.025quant 0.5quant 0.975quant   mode kld\nmath       0.090 0.012      0.067    0.089      0.113  0.089   0\nIntercept -5.651 0.692     -7.039   -5.641     -4.321 -5.621   0\n\nRandom effects:\n  Name    Model\n    rand.eff IID model\n\nModel hyperparameters:\n                       mean   sd 0.025quant 0.5quant 0.975quant mode\nPrecision for rand.eff 6.97 8.93       1.58     4.10      27.95 2.69\n\nDeviance Information Criterion (DIC) ...............: 380.37\nDeviance Information Criterion (DIC, saturated) ....: 204.31\nEffective number of parameters .....................: 29.47\n\nWatanabe-Akaike information criterion (WAIC) ...: 381.65\nEffective number of parameters .................: 26.02\n\nMarginal log-Likelihood:  -204.62 \n is computed \nPosterior summaries for the linear predictor and the fitted values are computed\n(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')\n\n\n\n\n\nExemple 2\nDans le jeu de données gorillas on cherche à comprendre la répartition de communautés de gorilles dans une région donnée en fonction de facteurs (végétations) ou de variable continue (altitude).\n\ndata(gorillas, package = \"inlabru\")\n\nOn importe l’objet liste gorillas qui contient 4 sous-listes contenant les localisations d’habitats de gorilles (nests), le maillage de la zone d’intérêt (mesh), la frontière du domaine (boundary) et les variables explicatives (gcov).\n\nnests <- gorillas$nests\nmesh <- gorillas$mesh\nboundary <- gorillas$boundary\ngcov <- gorillas$gcov\n\nsummary(gcov$vegetation)\n\nObject of class SpatialPixelsDataFrame\nCoordinates:\n       min      max\nx 580.1599 586.2320\ny 673.8742 679.0378\nIs projected: TRUE \nproj4string :\n[+proj=utm +zone=32 +datum=WGS84 +units=km +no_defs]\nNumber of points: 39600\nGrid attributes:\n  cellcentre.offset   cellsize cells.dim\nx          580.1737 0.02760054       220\ny          673.8885 0.02868664       180\nData attributes:\n      vegetation   \n Colonising:   48  \n Disturbed :23606  \n Grassland : 7001  \n Primary   : 7725  \n Secondary :  788  \n Transition:  432  \n\n\nLa construction du maillage peut se faire avec les fonctions de {INLA}:\n\ninla.mesh.2d(),\ninla.mesh.create(),\ninla.mesh.1d(),\ninla.mesh.basis(),\ninla.spde2.pcmatern().\n\nvoir la vignette suivante pour quelques exemples: https://inlabru-org.github.io/inlabru/articles/random_fields_2d.html.\n\nVisualisation des données gorilles\n\nggplot() +\n  gg(gcov$vegetation) +\n  gg(boundary) +\n  gg(nests, color = \"white\", cex = 0.5) +\n  coord_equal()\n\nRegions defined for each Polygons\n\n\n\n\n\n\nggplot() +\n  gg(gcov$vegetation) +\n  gg(mesh) +\n  gg(boundary) +\n  gg(nests, color = \"white\", cex = 0.5) +\n  coord_equal()\n\nWarning: Ignoring unknown parameters: linewidth\nIgnoring unknown parameters: linewidth\nIgnoring unknown parameters: linewidth\n\n\nRegions defined for each Polygons\n\n\n\n\n\nLes graphiques ci-dessus permettent de visualiser les différentes types de végétaions ainsi que les localisations d’habitats de gorilles dans la zone d’étude. Il est également possible de rajouter le maillage construit sur la zone. {inlabru} propose la fonction gg() permettant avac la grammaire ggplot2 de rajouter les différentes couches d’informations.\n\n\nModèle 1\nOn peut supposer un processus ponctuel spatial d’intensité\n\\[\\lambda(x,y)=\\exp(\\alpha_i(x,y))\\]\noù \\(\\alpha\\) est un paramètre correspondant à un type de végétation (modélisation factor full sans intercept donc).\n\ncomp1 <- coordinates ~ vegetation(gcov$vegetation, model = \"factor_full\") - 1\ncomp1alt <- coordinates ~ vegetation(gcov$vegetation, model = \"factor_contrast\") + 1\n\nPour construire un modèle expliquant les comptages de gorilles avec leurs répartitions dans la zone d’étude et prenant en compte les types de végétations, nous définissons la formule avec:\n\ncoordinates() la fonction de {sp} de récupération des coordonnées des habitats dans l’objet nests\nvegetation sera le mot utilisé dans les sorties du modèle faisant référence à la variable explicative gcov$vegetation (possible d’écrire le mot que l’on veut…)\nmodel = \"factor_full\" est pour indiquer que la variable explicative est un facteur. Il est possible d’utiliser “factor_full”, “factor_contrast” etc… suivant les types de contraintes que l’on souhaite appliquer au modèle. “factor_full” indique estimations de toutes les modalités mais il faut alors supprimer l’intercept afin d’être dans un cas identifiable.\n\nAprès avoir défini la formule du modèle, on estime les paramètres en utilisant la fonction lgcp() qui permet de modéliser un processus log-normalisé de Cox. Cette fonction est une surcouche de la fonction de base bru().\nLe LGCP est un modèle probabiliste de processus ponctuel observé dans un tissu spatial ou temporel.\n\nfit1 <- lgcp(components = comp1, # formule du modèle\n             data = nests,       # data set\n             samplers = boundary,  # frontière de la zone d'étude\n             domain = list(coordinates = mesh) # maillage de la zone\n             )\n\niinla: Iteration 1 [max:1]\n\n\nfit1 estime l’intensité des présences de gorilles dans la zone d’étude. Il est alors possible de représenter l’intensité moyenne de ces habitats:\n\npred.df <- fm_pixels(mesh, mask = boundary, format = \"sp\")\nint1 <- predict(fit1, pred.df, ~ exp(vegetation))\n\nggplot() +\n  gg(int1) +\n  gg(boundary, alpha = 0, lwd = 2) +\n  gg(nests, color = \"DarkGreen\") +\n  coord_equal()\n\nRegions defined for each Polygons\n\n\n\n\n\nPour visualiser les résultats du modèle, nous utilisons la fonction predict() (sans oublier de passer à l’exponentielle) et fm_pixels() qui en prenant la zone d’étude (mesh + frontière) crée l’objet spatial adéquat.\nNous remarquons que les intensités sont les plus fortes dans la végétation br{Primaire}, ce qui est logique. Ici, l’intensité représente le nombre d’habitats de gorilles par unité de surface. Attention donc à comment vous définissez les coordonnées de vos zones d’études.\nEn utilisant les fonctions fm_int()et predict() nous allons tenter d’estimer les abondances moyennes sachant que nous savons qu’il y a 647 habitats en réalité:\n\nips <- fm_int(mesh, boundary)\nLambda1 <- predict(fit1, ips, ~ sum(weight * exp(vegetation)))\nLambda1\n\n      mean       sd  q0.025    q0.5   q0.975  median mean.mc_std_err\n1 649.1022 25.26657 601.526 651.513 695.9524 651.513        2.526657\n  sd.mc_std_err\n1      1.829485\n\n\n\n# Calcul de la surface de la zone\nsum(ips$weight) # some des surfaces de chaque triangle du mesh\n\n[1] 19.87366\n\nsf::st_area(sf::st_as_sf(boundary)) # surface totale \n\n19.87366 [km^2]\n\n\n\n\nModèle avec utilisation SPDE\nDans cette section, nous allons essayre d’expliquer la répartition des habitats en rajoutant au facteur vegetation une modélisation SPDE (Stochastic partial differential equations). Il faut pour cela compléter la définition du maillage par l’ajout d’une structure de Matern en utilisant la fonction {INLA} inla.spde2.pcmatern() puis réécrire la définition de la forule du modèle INLA. Le modèle intègre alors un champ gaussien avec covariance de Matérn.\n\\[\\lambda(x,y)=\\exp(\\alpha_i(x,y)+\\xi(x,y))\\]\navec \\(\\xi\\) suivant un champ gaussien.\n\npcmatern <- inla.spde2.pcmatern(mesh,\n  prior.sigma = c(0.1, 0.01),\n  prior.range = c(0.1, 0.01)\n)\n\ncomp2 <- coordinates ~\n            -1 +\n            vegetation(gcov$vegetation, model = \"factor_full\") +\n            mySmooth(coordinates, model = pcmatern)\n\nfit2 <- lgcp(components = comp2, \n             data = nests, \n             samplers = boundary, \n             domain = list(coordinates = mesh))\n\niinla: Iteration 1 [max:1]\n\n\nOn représente l’intensité médiane de la surface:\n\nint2 <- predict(fit2, pred.df, ~ exp(mySmooth + vegetation), n.samples = 1000)\n\nggplot() +\n  gg(int2, aes(fill = q0.025)) +\n  gg(boundary, alpha = 0, lwd = 2) +\n  gg(nests) +\n  coord_equal()\n\nRegions defined for each Polygons\n\n\n\n\n\net l’intensité intégrée attendue (moyenne des abondances):\n\nLambda2 <- predict(fit2,\n                   fm_int(mesh, boundary),\n                   ~ sum(weight * exp(mySmooth + vegetation)))\n\nLambda2\n\n      mean       sd  q0.025     q0.5   q0.975   median mean.mc_std_err\n1 682.5278 23.57212 644.344 681.9518 725.4105 681.9518        2.357212\n  sd.mc_std_err\n1       1.36014\n\n\nLook at the contributions to the linear predictor from the SPDE and from vegetation.\nExaminons les contributions au prédicteur linéaire de la partie SPDE et de celle due à la végatation.\nLa fonction scale_fill_gradientn() définit l’échelle pour la légende du graphique. Dans cet exemple, on le définit tel que cela prenne en compte toute la gamme de valeurs des 3 prédicteurs linéaires. Par défaut, ce sont les médianes qui sont représentées.\n\nlp2 <- predict(fit2, \n               pred.df, ~ list(\n                        smooth_veg = mySmooth + vegetation,\n                        smooth = mySmooth,\n                        veg = vegetation\n              ))\n\nlprange <- range(lp2$smooth_veg$median, lp2$smooth$median, lp2$veg$median)\ncsc <- scale_fill_gradientn(colours = brewer.pal(9, \"YlOrRd\"), limits = lprange)\n\nplot.lp2 <- ggplot() +\n  gg(lp2$smooth_veg) +\n  csc +\n  theme(legend.position = \"bottom\") +\n  gg(boundary, alpha = 0) +\n  ggtitle(\"mySmooth + vegetation\") +\n  coord_equal()\n\nRegions defined for each Polygons\n\nplot.lp2.spde <- ggplot() +\n  gg(lp2$smooth) +\n  csc +\n  theme(legend.position = \"bottom\") +\n  gg(boundary, alpha = 0) +\n  ggtitle(\"mySmooth\") +\n  coord_equal()\n\nRegions defined for each Polygons\n\nplot.lp2.veg <- ggplot() +\n  gg(lp2$veg) +\n  csc +\n  theme(legend.position = \"bottom\") +\n  gg(boundary, alpha = 0) +\n  ggtitle(\"vegetation\") +\n  coord_equal()\n\nRegions defined for each Polygons\n\nmultiplot(plot.lp2, plot.lp2.spde, plot.lp2.veg, cols = 3)\n\n\n\n\n\n\n\nExemple 3\nNous nous intéressons à un jeu de données concernant la prévalence de la malaria en Gambie (disponible dans le package {geoR}). Cet exemple est repris du livre “Spatial and Spatio-temporal Bayesian Models with R-INLA.\n\ndata(gambia, package = \"geoR\")\n# les coordonnées correspondent au village où se trouve les enfants\n# create one index for each of the 65 villages\nvillage_index <- unite(gambia, col = \"lon_lat\", sep = \"_\", \"x\", \"y\") %>% \n  pull(\"lon_lat\") %>% \n  factor(labels = 1:65)\ngambia <- gambia %>%\n  add_column(village_index) \n\nOn transforme les données et on transforme le jeu de données en type {SpatialPointsDataFrame}.\n\ngambia <- gambia %>%\n  mutate(x = x * 0.001, # to km\n         y = y * 0.001, # to km\n         age = age / 365) \ncoordinates(gambia) <- c(\"x\", \"y\") \nclass(gambia)\n\n[1] \"SpatialPointsDataFrame\"\nattr(,\"package\")\n[1] \"sp\"\n\n\nOn définit ensuite un maillage pour le champ spatial avec un maillage plus fin dans la zone où il y a des observations et qui “déborde” avec un maillage plus grossier.\n\nhull = inla.nonconvex.hull(gambia,convex = -0.1)\ngambia_mesh <- inla.mesh.2d(boundary = hull,\n                            offset = c(30, 60), max.edge = c(20,40))\n\nplot(gambia_mesh,main=\"\",asp=1)\npoints(gambia,pch=21,bg=\"white\",cex=1.5,lwd=1.5)\n\n\n\n\nOn définit à partir du maillage le champ spatial spde qui correspond à un champ spatial gaussien avec une covariance Matérn. Nous considérons les lois a priori par défaut sur les paramètres de variance et de portée du champ spatial.\n\ngambia_spde <- inla.spde2.matern(mesh = gambia_mesh, alpha=2)\n\nTout est prêt pour définir le modèle à ajuster et son estimation : Pour l’enfant \\(j\\) du village \\(i\\), nous supposons\n\\[Y_{ij}|V_i\\overset{ind}{\\sim}b(p_{ij})\\]\navec \\[S_i\\sim GRF, \\quad V_i\\overset{ind}{\\sim}\\mathcal{N}(0,\\sigma^2_V)\\] et \\[p_{ij}=\\mu+\\beta_1 \\cdot treated_{ij}+\\beta_2 \\cdot netuse_{ij}+\\beta_3 \\cdot age_{ij}+\\beta_4 \\cdot green_{ij}+beta_5\\cdot phc_{ij}+S_i+V_i.\\]\n\nformula = pos ~ -1 +\n  Intercept(1) +\n  treated +\n  netuse +\n  age +\n  green +\n  phc +\n   spatial_field(coordinates, model=gambia_spde) +\n  village(village_index, model=\"iid\")\n\nfit <- bru(components = formula,\n           data = gambia,\n           family= \"binomial\"\n)\n\niinla: Iteration 1 [max:1]\n\nsummary(fit)\n\ninlabru version: 2.8.0\nINLA version: 23.04.24\nComponents:\nIntercept: main = linear(1), group = exchangeable(1L), replicate = iid(1L)\ntreated: main = linear(treated), group = exchangeable(1L), replicate = iid(1L)\nnetuse: main = linear(netuse), group = exchangeable(1L), replicate = iid(1L)\nage: main = linear(age), group = exchangeable(1L), replicate = iid(1L)\ngreen: main = linear(green), group = exchangeable(1L), replicate = iid(1L)\nphc: main = linear(phc), group = exchangeable(1L), replicate = iid(1L)\nspatial_field: main = spde(coordinates), group = exchangeable(1L), replicate = iid(1L)\nvillage: main = iid(village_index), group = exchangeable(1L), replicate = iid(1L)\nLikelihoods:\n  Family: 'binomial'\n    Data class: 'SpatialPointsDataFrame'\n    Predictor: pos ~ .\nTime used:\n    Pre = 0.947, Running = 1.47, Post = 0.125, Total = 2.54 \nFixed effects:\n            mean    sd 0.025quant 0.5quant 0.975quant   mode kld\nIntercept -1.295 1.282     -3.733   -1.327      1.312 -1.398   0\ntreated   -0.387 0.201     -0.782   -0.387      0.006 -0.387   0\nnetuse    -0.347 0.157     -0.655   -0.347     -0.039 -0.347   0\nage        0.246 0.044      0.159    0.246      0.332  0.246   0\ngreen      0.012 0.025     -0.038    0.012      0.060  0.014   0\nphc       -0.323 0.227     -0.772   -0.322      0.122 -0.321   0\n\nRandom effects:\n  Name    Model\n    spatial_field SPDE2 model\n   village IID model\n\nModel hyperparameters:\n                          mean    sd 0.025quant 0.5quant 0.975quant  mode\nTheta1 for spatial_field  1.32 0.836     -0.172     1.26       3.10  1.04\nTheta2 for spatial_field -2.50 0.708     -4.006    -2.45      -1.24 -2.27\nPrecision for village     4.83 2.423      1.684     4.32      10.97  3.45\n\nDeviance Information Criterion (DIC) ...............: 2326.24\nDeviance Information Criterion (DIC, saturated) ....: 2326.24\nEffective number of parameters .....................: 48.46\n\nWatanabe-Akaike information criterion (WAIC) ...: 2325.39\nEffective number of parameters .................: 46.41\n\nMarginal log-Likelihood:  -1227.34 \n is computed \nPosterior summaries for the linear predictor and the fitted values are computed\n(Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')\n\n\nOn peut accéder aux distributions marginales des effets aléatoires et des hyperparamètres :\n\nfit$summary.random \nfit$summary.hyperpar\n\nNous pouvons tracer les distributions a posteriori marginales des effets, par exemple :\n\nage <- fit$marginals.fixed[[4]]\nggplot(data.frame(inla.smarginal(age)), aes(x, y)) +\n  geom_line() +\n  theme_bw()\n\n\n\nrfprecision <- fit$marginals.hyperpar$`Precision for village`\nggplot(data.frame(inla.smarginal(rfprecision)), aes(x, y)) +\n  geom_line() +\n  theme_bw()\n\n\n\n\nNous essayons de représenter le champ gaussien latent\n\ndomain_lims <- apply(hull$loc, 2, range)\ngrd_dims <- round(c(x = diff(domain_lims[, 1]), \n                    y = diff(domain_lims[, 2])) / 1)\nmesh_proj <- fm_evaluator(\n  gambia_mesh,\n  xlim = domain_lims[, 1], ylim = domain_lims[, 2], dims = grd_dims\n)\n\nspatial_field <- data.frame(\n  median = inla.link.invlogit(fit$summary.random$spatial_field$\"0.5quant\"),\n  range95 = (inla.link.invlogit(fit$summary.random$spatial_field$\"0.975quant\") -\n               inla.link.invlogit(fit$summary.random$spatial_field$\"0.025quant\"))\n)\n\npredicted_field <- fm_evaluate(mesh_proj, spatial_field) %>%\n  as.matrix() %>%\n  as.data.frame() %>%\n  bind_cols(expand.grid(x = mesh_proj$x, y = mesh_proj$y), .) %>%\n  pivot_longer(cols = -c(\"x\", \"y\"),\n               names_to = \"metric\",\n               values_to = \"value\")\n# Median\nggplot(filter(predicted_field, metric == \"median\")) +\n  aes(x = x, y = y, fill = value) +\n  geom_raster() +\n  scale_fill_viridis_c()\n\n\n\n# 95% range\nggplot(filter(predicted_field, metric == \"range95\")) +\n  aes(x = x, y = y, fill = value) +\n  geom_raster() +\n  scale_fill_viridis_c()"
  },
  {
    "objectID": "R_INLA.html#references",
    "href": "R_INLA.html#references",
    "title": "R INLA",
    "section": "References",
    "text": "References\n\nhttps://www.pymc.io/projects/examples/en/latest/gaussian_processes/log-gaussian-cox-process.html\nFabian E. Bachl, Finn Lindgren, David L. Borchers, and Janine B. Illian (2019), inlabru: an R package for Bayesian spatial modelling from ecological survey data, Methods in Ecology and Evolution, British Ecological Society, 10, 760–766, doi:10.1111/2041-210X.13168\nFunwi-Gabga, N. and Mateu, J. (2012) Understanding the nesting spatial behaviour of gorillas in the Kagwene Sanctuary, Cameroon. Stochastic Environmental Research and Risk Assessment 26 (6), 793-811.\nhttps://www.muscardinus.be/2018/07/inlabru-bru/\nhttps://inlabru-org.github.io/inlabru/index.html"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "FinistR : bootcamp R à Roscoff",
    "section": "",
    "text": "L’atelier Finist’R 2023 – ou bootcamp R du groupe State Of The R s’est déroulé à la station biologique de Roscoff du 21 au 25 août 2023.\nStateoftheR est un réseau du département MathNum INRAE.\n\n\nIl s’agissait de la septième édition de l’atelier Finist’R. Cet atelier réunit annuellement un groupe de chercheurs, ingénieurs, doctorants, tous utilisateurs avancés de R et développeurs de paquets pour explorer les dernières fonctionnalités du logiciel et les nouvelles pratiques de développement. A l’issue de l’atelier le collectif produit une synthèse de cette veille logiciel de manière à progresser collectivement dans l’utilisation du logiciel mais surtout dans la production d’outils statistiques à destination de la communauté.\nLe résultat de cette semaine est disponible sur cette page"
  },
  {
    "objectID": "index.html#participants",
    "href": "index.html#participants",
    "title": "FinistR : bootcamp R à Roscoff",
    "section": "Participants",
    "text": "Participants\nEmré Anakok, Julie Aubert, Pierre Barbillon, Barbara Bricout, Caroline Cognot, Félix Cheysson, Julien Chiquet, Annaïg De Walsche, Marie-Pierre Etienne, Armand Favrot, Hugo Gangloff, Pierre Gloaguen, Jérémy Lamouroux, Corentin Lothodé, Mahendra Mariadassou, Tristan Mary-Huard, Isabelle Sanchez, Florian Teste, Théodore Vanrentherghem, Emily Walker."
  },
  {
    "objectID": "index.html#idées-explorées",
    "href": "index.html#idées-explorées",
    "title": "FinistR : bootcamp R à Roscoff",
    "section": "Idées explorées",
    "text": "Idées explorées"
  },
  {
    "objectID": "index.html#soutien",
    "href": "index.html#soutien",
    "title": "FinistR : bootcamp R à Roscoff",
    "section": "Soutien",
    "text": "Soutien"
  },
  {
    "objectID": "Readme.html",
    "href": "Readme.html",
    "title": "Finist'R 2023",
    "section": "",
    "text": "website\n\n\nL’atelier Finist’R 2023 – ou bootcamp R s’est déroulé à la station biologique de Roscoff du 21 au 25 août 2023.\nIl s’agit de la septième édition de l’atelier Finist’R. Cet atelier réunit annuellement un groupe de chercheurs, ingénieurs, doctorants, tous utilisateurs avancés de R et dévelopeurs de paquets pour explorer les dernières fonctionalités du logiciel et les nouvelles pratiques de développement. A l’issu de l’atelier le collectif produit une synthèse de cette veille logiciel de manière à progresser collectivement dans l’utilisation du logiciel mais surtout dans la production d’outils statistiques à destination de la communauté.\nLa restitution se fait sous forme de site web. Le site de l’édition 2023 sera disponible ici"
  },
  {
    "objectID": "instructions.html",
    "href": "instructions.html",
    "title": "Instructions pour le dépot sur le site web",
    "section": "",
    "text": "Créer une branche propre à l’atelier nommée explicitement mon_nom_parlant et basculer dessus\n\ngit checkout -b mon_nom_parlant\n\nCréer un fichier Rmarkdown de restitution de votre atelier fichier.Rmd dans votre branche\n\ngit add fichier.Rmd\ngit commit -m \"restitution atelier\"\n\nPousser vos modifications sur le serveur distant\n\ngit  push --set-upstream origin mon_nom_parlant ou\ngit  push\n\nFaire une pull request (PR) sur github\nindiquer dans le message de la PR la liste des packages ou autres besoins\nQuand la PR passe les tests, demander le merge.\ncorriger les erreurs éventuelles dans la compilation du Rmarkdown\nles admins peuvent avoir à mettre à jour l’image docker"
  },
  {
    "objectID": "instructions.html#détails-du-fonctionnement",
    "href": "instructions.html#détails-du-fonctionnement",
    "title": "Instructions pour le dépot sur le site web",
    "section": "Détails du fonctionnement",
    "text": "Détails du fonctionnement\n\nLe docker\nLien vers la fiche pense-bête : [https://www.docker.com/sites/default/files/d8/2019-09/docker-cheat-sheet.pdf]\nPour créer des images Docker en local sur sa machine, voici une liste de commandes utiles\n\nPour construire une image docker, il faut créer un fichier Dockerfile qui contient la recette du Docker. Pour ce site le ficher Dockerfile a la forme suivante\n\n\n\n\nFROM rocker/geospatial:4\nRUN export DEBIAN_FRONTEND=noninteractive; apt-get -y update \\\n && apt-get install -y pandoc \\\n    pandoc-citeproc\nRUN R -e \"install.packages('remotes')\"\nRUN R -e \"install.packages('microbenchmark')\"\nRUN R -e \"install.packages('purrr')\" # map function\nRUN R -e \"install.packages('BiocManager')\" # map function\nRUN R -e \"BiocManager::install('BiocPkgTools')\" \nRUN R -e \"install.packages('httr')\" # GET function\nENV R_CRAN_WEB=\"https://cran.rstudio.com/\" \nRUN R -e \"install.packages('cowplot')\" # GET function\nRUN R -e \"install.packages('torch')\"\nRUN R -e \"torch::install_torch(type = 'cpu')\"\nRUN R -e \"install.packages('PLNmodels')\"\nRUN R -e \"install.packages('torchvision')\"\n\nRUN apt-get update \\\n && apt-get install -y --no-install-recommends \\\n  jags \\\n  mercurial gdal-bin libgdal-dev gsl-bin libgsl-dev \\ \n  libc6-i386\n  \n  \nRUN R -e \"install.packages('INLA',repos=c(getOption('repos'),INLA='https://inla.r-inla-download.org/R/stable'), dep=TRUE)\"\nRUN R -e \"install.packages('reticulate')\"\nRUN R -e \"install.packages(c('inlabru', 'lme4', 'ggpolypath', 'RColorBrewer', 'geoR'))\"\n\n\npuis demander la construction de l’image à l’aide de la commande\n\n docker build -t nom_depot_dockerhub/nom_du_repo:version  . ## avec un nom\n\net enfin pousser sur Dockerhub\n\n docker push nom_depot_dockerhub/nom_du_repo:version\n\n\n\nLes actions\nDans les action de Github, on peut spécifier un container docker à utiliser, c’est ce que fait la ligne container du fichier d’action suivant, utiliser pour créer ce site web\n\n\nname: website\non:\n  push:\n    branches:\n      - main\n\njobs:   \n  build:\n    name: Build website with rmarkdown\n    runs-on: ubuntu-latest\n    container: stateofther/r-finistr2023:0.2\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Generate slides\n        run: \"quarto render\"\n      - name: GitHub Pages action\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./_site"
  }
]