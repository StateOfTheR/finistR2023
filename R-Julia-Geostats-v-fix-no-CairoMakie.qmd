---
title: "Comparaison de l'efficatit√© de R et Julia en Geostatistiques"
format:
  html:
    code-fold: false
    warning: false
    error: false
    toc: true
editor: source
execute:
  enabled: true
---

L'objectif est de comparer des packages R, et Julia pour du krigeage.

On va utiliser :

\- R : gstat

\- R : GeoModels

\- Julia : GeoStats

On compare les points suivant :

\- simplicit√© des donn√©es d'entr√©e

\- concision du code

\- vitesse d'ex√©cution

\- type d'estimation

Pour chaque package, on calculera pour les m√™mes donn√©es le variogramme empirique, puis on ajustera un variogramme th√©orique et on fera un krigeage.

## Donn√©es

```{r}
library(sp)
library(sf)
library(terra)
data(meuse)
data(meuse.grid)

library(tidyverse)
library(gstat)
library(GeoModels)
```

On utilise les donn√©es meuse du package sp. Celles-ci contiennent des donn√©es de concentration en m√©taux pr√®s de la meuse, avec des coordonn√©es cart√©siennes en m.

Pour travailler sur ces concentrations, on passera tout au log afin de les normaliser.

Pour la visualisation en R, on utilise le package terra.

# 0 - Le package terra

-   derni√®re version : 1.7-39 du 22/06/2023

-   Travail des donn√©es spatiales sous 2 formes : raster et vector.

    -   raster = grilles rectangulaires, adapt√© aux donn√©es continues -\> Classe SpatRaster

    -   vector = points, lignes, polygones = donn√©es discr√®tes. -\> classe SpatVector

-   D√©but de la doc = r√©cap des m√©thodes importantes (il faut bien, la doc fait 300 pages)

-   Sert √† manipuler, visualiser des objets spatiaux, notamment apr√®s les calculs pour simplifier le travail sur les r√©sultats.

M√©thode rast = cr√©er un objet de classe SpatRaster. Le type de la 1ere entr√©e peut varier.

```{r}
meuseRast = rast(meuse.grid,type="xyz",crs = "EPSG:2154")
meuseVect = vect(meuse,geom=(c('x','y')))
```

```{r}
meuseRastCd = rast(select(meuse,x,y,zinc),type="xyz")
log(meuseRastCd)
meuseRastCu = rast(select(meuse,x,y,copper),type="xyz")
meuseRastCuCd = c(meuseRastCd,meuseRastCd) #methode c() = combinaison de layers


```

# 1 - Package R gstat

gstat est disponible sur le CRAN : https://CRAN.R-project.org/package=gstat

On peut y trouver √©galement un tutoriel sur le dataset "meuse" utilis√© ici, qui pr√©sentent le type de donn√©es spatiales utilis√©es par le package (spatial dataframe, donn√©es grill√©es) et les m√©thodes permettant de travailler avec (m√©thodes de visualisation du package sp, ajustement de variogrammes, directionnels ou non, krigeage, simulation conditionnelle).

La version la plus ancienne sur les archives du CRAN date de 2003.

Au d√©part, les donn√©es spatiales support√©es √©taient celles du package sp, mais les donn√©es de type sf le sont √©galement.

INSERER AU BON ENDROIT LES CELLULES

## Transformation au format sf

```{r}
df = select(meuse,x,y,cadmium,zinc)
df_grid = select(meuse.grid,x,y)
df_sf <- df %>% 
  sf::st_as_sf( coords = c('x','y'))

df_sf <- sf::st_make_valid(df_sf)
df_grid_sf = df_grid%>% sf::st_as_sf(coords = c('x','y'))%>%sf::st_make_valid()
ggplot(df, aes(y=log(zinc))) + 
  geom_boxplot(notch=FALSE) +
  labs(y = "Log(Zn concentration)") +
  theme_minimal() +                                   
  theme(
    axis.text.x = element_blank(),
    axis.ticks = element_blank(),
    axis.line = element_blank()
  )
```

## Variogramme empirique

Pour simplifier la comparaison avec le package Julia, on va se contenter d'une moyenne constante sans introduire de pr√©dicteurs : on demande donc log(zinc)\~1. Si on avait voulu, comme dans le tutoriel du package, expliquer la moyenne par la distance √† la rivi√®re, il faudrait modifier cette formule en log(zinc)\~distance apr√®s avoir rajout√© une colonne distance au sf dataframe.

Appeler plot sur un objet issu de variogram permet d'en obtenir un trac√©.

```{r}
start_time <- Sys.time()
test <- variogram(log(zinc)~1  , df_sf,cutoff = 2000)
end_time <- Sys.time()
end_time - start_time
plot(test)

```

## Le type vgm

Plusieurs mod√®les de variogrammes spatiaux sont disponibles dans la librairie.

```{r}
show.vgms()
(vgm())
```

Un variogramme th√©orique est un objet de type vgm, qui doit √™tre initialis√© avec des param√®tres avant de l'ins√©rer dans la fonction d'estimation.

Un inconv√©nient dans la cr√©ation d'un objet vgm est l'absence de nom pour certains param√®tres, il faut se r√©f√©rer √† la documentation pour savoir √† quel place il faut rentrer quel argument lorsque'on appelle vgm(). Ne pas renseigner un argument initialise celui-ci √† NA. Utiliser fit.variogram sur un objet avec des NA fait appel √† une √©tape suppl√©mentaire qui initialise avec des param√®tres issus du variogramme empirique. Cela emp√™che de contr√¥ler les valeurs initiales de l'estimation.

## Estimation du variogramme th√©orique

Les param√®tres du variogramme th√©orique sont ajust√©s par moindres carr√©s sur le variogramme empirique.

vgmModelwav \<- fit.variogram(test,vgm('Wav'))

```{r}
vgmModelexp <- fit.variogram(test, vgm(2, "Exp", 1000))
vgmModelexp
vgmModelmat <- fit.variogram(test, vgm(10, "Mat", 300, 4.5, kappa = 0.7))
vgmModelmat
vgmModelNA <- fit.variogram(test,vgm('Mat'))
vgmModelNA

start_time <- Sys.time()
vgmModelwav <- fit.variogram(test,vgm('Wav'))
end_time <- Sys.time()
end_time - start_time

vgmModelwav

```



La fonction plot() appel√©e sur un mod√®le estim√© trace en continu le variogramme th√©orique et en points le variogramme empirique.

```{r}
plot(test, vgmModelmat)
plot(test, vgmModelwav)
```

## Krigeage

```{r}
start_time <- Sys.time()
krig <- krige(log(zinc)~1 , df_sf, df_grid_sf, model = vgmModelmat)
end_time <- Sys.time()
end_time - start_time


Kres_pred = data.frame(x=meuse.grid$x,y=meuse.grid$y,pred=krig$var1.pred)
krig_res<- terra::rast(Kres_pred, type="xyz", crs="EPSG:2154")


Kres_var = data.frame(x=meuse.grid$x,y=meuse.grid$y,pred=krig$var1.var)
krig_var<- terra::rast(Kres_var, type="xyz", crs="EPSG:2154")

plot((krig_res), main = 'Krigeage de log(zinc) - gstat')
plot(krig_var,main = 'Erreur de krigeage pour log(zinc) - gstat')
```

# 2 - Package R GeoModels

GeoModels est un package relativement r√©cent (2022), il prend la suite de CompRandFld suite √† une mise √† jour majeure de R.

Il est disponible sur le CRAN :

https://CRAN.R-project.org/package=GeoModels

Le package propose des fonctions pour de la simulation, de l'inf√©rence et de la pr√©diction de champs spatiaux et spatio-temporels, univari√© ou multivari√©. Il contient des m√©thode spour des champs Gaussiens et non Gaussiens.

On peut travailler en coordonn√©es euclidiennes et sph√©riques.

GeoModels propose de faire des mod√®les spatiaux et spatiotemporels.

Les estimations se font par maximisation de vraisemblance composite.

Du fait de la vari√©t√© de mod√®les et de donn√©es possibles en entr√©e (spatial, spatiotemporel, 1 ou plusieurs variables ...), chaque fonction est d√©finie g√©n√©ralement pour prendre en entr√©e des donn√©es (notamment data et coordonn√©es) sous plusieurs types. Dans tous les cas, on ne d√©pend pas de structures "√©volu√©es", on n'a besoin que de vecteurs et de matrices. En contrepartie, on est probablement moins libres sur les syst√®mes de coordonn√©es.

Les donn√©es en entr√©e doivent √™tre, si on fait du spatial uniquement :

\- data : un vecteur de taille $d$

\- coordx : une matrice $d \times 2$ si on met directement les coordonn√©es, ou un vecteur de taille $d$ si on s√©pare les coordonn√©es

\- coordy : NULL si on a d√©j√† mis les 2 coordonn√©es dans coordx, vecteur de taille $d$ sinon.

Il n'y a donc pas besoin de g√©rer des types de donn√©es spatiales comme dans gstat.

```{r}

data =log(df$zinc)

coordx = df$x

coordy = df$y
```

## Variogramme empirique

```{r}


# Variogramme empirique : 
start_time <- Sys.time()
emp_vario = GeoVariogram(data, coordx, coordy=coordy,numbins = 16,maxdist = 2000)

end_time <- Sys.time()
end_time - start_time

plot(emp_vario,main = "Variogramme empirique Zinc - GeoModels")


```

## Mod√®les support√©s

Voir documentation, fonction "GeoCovMatrix"

CorrParam, et NuisParam permettent d'obtenir la listes des param√®tres requis pour les mod√®les.

```{r}
NuisParam('Gaussian')
CorrParam("Exp")
CorrParam('Matern')

```

## Estimation du variogramme th√©orique

L'estimation n√©cessite de donner en entr√©e deux listes, fixed et start, correspondant aux param√®tres fix√©s et libres dans l'ajustement.

ATTENTION : si on ne fixe rien, il ne faut pas une liste vide mais un NULL, ou alors ne pas renseigner l'argument (NULL est la valeur par d√©faut)

L'algorithme v√©rifiera automatiquement que tous les param√®tres n√©cessaires sont remplis. Il n'y a pas comme dans gstat de m√©thode qui rempli automatiquement des oublis, il faut v√©rifier avec les fonctions pr√©c√©dentes qu'on a bien tout initialis√©.

```{r}

fixed = NULL

start = list( mean = 0 , sill=0.5,smooth=0.7,scale = 300,nugget = 0.044)

modelemat = GeoFit(data, coordx=coordx, coordy=coordy, fixed = fixed, start=start, 

corrmodel="Matern",distance="Eucl",maxdist = 2000)

modelemat

# Vario fit : il faut mettre en entr√©e des valeurs de d√©part et des valeurs qu'on fixe pour les param√®tres

fixed = list(nugget = 0.044) #fixe la valeur obtenue avec gstat

start = list( mean = 0 , sill=0.5,smooth=0.7,scale = 300)

modelemat2 = GeoFit(data, coordx=coordx, coordy=coordy, fixed = fixed, start=start, 

corrmodel="Matern",distance="Eucl",maxdist = 2000)

modelemat2



```

```{r}
fixed = NULL

start = list( mean = 0 , sill=0.5,scale = 300,nugget = 0.044)

start_time <- Sys.time()
modelewav = GeoFit(data, coordx=coordx, coordy=coordy, fixed = fixed, start=start, 

corrmodel="Wave",distance="Eucl",maxdist = 2000)

end_time <- Sys.time()
end_time - start_time

modelewav


```

On peut comparer les mod√®les que l'on vient de faire avec le variogramme empirique :

```{r}

# Comparaison avec l'empirique matern :

GeoCovariogram(modelemat, distance="Eucl",show.vario= TRUE,vario = emp_vario)
GeoCovariogram(modelemat2, distance="Eucl",show.vario= TRUE,vario = emp_vario)



# Comparaison avec l'empirique Wave :

GeoCovariogram(modelewav, distance="Eucl",show.vario= TRUE,vario = emp_vario)


```

## Krigeage

```{r}
locskrig = data.frame (x =meuse.grid$x,y= meuse.grid$y)

start_time <- Sys.time()
krig_geomodels = GeoKrig(loc= locskrig,coordx=coordx, coordy=coordy,corrmodel = 'Wave',param = c(modelemat$fixed,modelewav$param),mse =TRUE,data=data)

end_time <- Sys.time()
end_time - start_time

coords  = cbind(coordx,coordy)

Kres_pred_geo = data.frame(x=meuse.grid$x,y=meuse.grid$y,pred=krig_geomodels$pred)

krig_res_geo<- terra::rast(Kres_pred_geo, type="xyz", crs="EPSG:2154")

Kres_var_geo = data.frame(x=meuse.grid$x,y=meuse.grid$y,pred=krig_geomodels$mse)

krig_var_geo<- terra::rast(Kres_var_geo, type="xyz", crs="EPSG:2154")

plot((krig_res_geo), main = 'Krigeage de log(zinc) - GeoModels')

plot(krig_var_geo,main = 'Erreur de krigeage pour log(zinc) - GeoModels')
```

# 3 - Package Julia GeoStats

Julia est un langage de programmation de haut niveau, performant et dynamique pour le calcul scientifique, avec une syntaxe famili√®re aux utilisateurs d'autres environnements de d√©veloppement similaires (Matlab, R, Scilab, Python, etc.). Il fournit un compilateur sophistiqu√©, un syst√®me de types dynamiques avec polymorphisme param√©tr√©, une ex√©cution parall√®le distribu√©e, des appels directs de fonctions C, Fortran et Python. (source Wikipedia)

Un avantage de Julia est la possibilit√© d'√©crire en LaTeX dans les lignes de code. 

GeoStats est un package r√©cent (avril 2015), sa derni√®re mise √† jour date de 3 mois, c'est le package majeur en statistiques spatiales de Julia.

Il est disponible sur le :

https://juliaearth.github.io/GeoStats.jl/stable/

Pour l'installer faire la commande suivante dans le terminal de votre IDE : ]add GeoStats

Le package propose des fonctions pour de la simulation, de l'inf√©rence et de la pr√©diction de champs spatiaux

On peut travailler en coordonn√©es euclidiennes et sph√©riques.

GeoStats propose de faire des mod√®les spatiaux. Sa particularit√© va √™tre de tester tous les variogrammes disponibles (dans une m√™me ex√©cution) dans le package pour obtenir le plus optimis√© avec les param√®tres qui fonctionnent le mieux.


## Biblioth√®ques Julia

```{r, eval = FALSE}
# Import package
using GeoDataFrames, Distributed, StatsAPI, Plots, DelimitedFiles, DataFrames, CSV, GeoStats, Rasters,  Shapefile,GeoTables, CairoMakie; const GDF=GeoDataFrames; import WGLMakie as Mke
```

## Importer les donn√©es

```{r, eval = FALSE}
# Get the current working directory
current_directory = pwd()

#import data
meuse = CSV.read(joinpath(current_directory,"meuse.txt"),DataFrame;delim="," )
meuse_grid = CSV.read(joinpath(current_directory, "meuse.grid.txt"),DataFrame; delim=",")
meuse_geom = georef(CSV.File(joinpath(current_directory,"meuse.txt")),(:x,:y,:cadmium))

#describe data
describe(meuse)
describe(meuse_grid)
```

## Transformation en donn√©es spatiale

```{r, eval = FALSE}
#add log zinc to the data
logmeuse = log.(meuse.zinc)
meuse.logzinc = logmeuse

#create coord of data meuse
coord = [(x, y) for (x, y) in zip(meuse.x, meuse.y)]
#create spatial object of meuse
meuselog = georef(meuse[:,["x","y","logzinc"]],coord)

# list of properties with coordinates
props = (logzinc=meuse.logzinc,)
ùíü = georef(props, coord)
```

## Variogramme

Le fit pour tester les diff√©rents variogramme va nous donner le
SineHoleVariogram avec tous les param√®tres optimis√©. On d√©cide √† la base
d‚Äôutiliser ce dernier mais il s‚Äôav√®re qu‚Äôil ne donne pas de bon r√©sultat
pour le Krigeage. On utilisera donc un variogramme de Mat√©rn. Si vous
voulez observer ce dernier dans le krigeage il suffira de mettre dans la
fonction kriging, le variogramme d√©sir√©.

```{r, eval = FALSE}
# empirical variogram

@time empvario = EmpiricalVariogram(meuselog, :logzinc, maxlag = 2000.)

## plot of empirical variogram
# Mke.plot(empvario) plot interactive
# CairoMakie.plot(empvario) #plot sans interaction
## plot theorical variogram
# CairoMakie.plot(MaternVariogram(range=691, nugget=0.04))
# CairoMakie.plot(SineHoleVariogram(range=691, nugget=0.25))

#fit theorical and empirical variogramand 
@time fitvario = fit(Variogram, empvario)

# CairoMakie.plot(empvario)
# CairoMakie.plot!(fitvario, maxlag = 2000.)
# CairoMakie.current_figure()
```

## Cr√©ation de la grille

```{r, eval = FALSE}
# grid creation
# Convert the x and y coordinates to numeric arrays
x_coords = Float64.(meuse.x)
y_coords = Float64.(meuse.y)# Create the Cartesian grid dimensions, origin, and spacing
dims = (100, 100)  # Number of grid points in x and y directions
origin = (minimum(x_coords), minimum(y_coords)) # Lower left corner of the grid
spacing = ((maximum(x_coords) - minimum(x_coords)) / (dims[1] - 1),
           (maximum(y_coords) - minimum(y_coords)) / (dims[2] - 1)) 
 # Cell spacing in x and y directions# Create the CartesianGrid
ùí¢ = CartesianGrid(dims, origin, spacing)
```

## Krigeage

```{r, eval = FALSE}
ùí´ = EstimationProblem(ùíü, ùí¢, :logzinc)

@time ùíÆ = Kriging(:logzinc => (variogram=MaternVariogram(nugget = 0.21,sill = 0.59,range=706.78),))

# perform estimation
@time Œ© = solve(ùí´, ùíÆ)

# CairoMakie.plot(Œ©.geometry, color = Œ©.logzinc_variance)
```

## Affichage du Krigeage

```{r, eval = FALSE}
#Export Kriging
GeoTables.save(joinpath(current_directory,"data_geostats_julia/Kriging2.shp"), Œ©,force=true )

#read kriging
shape =  Shapefile.Handle(joinpath(current_directory,"data_geostats_julia/Kriging2.shp")).shapes
# read grid 
grid_shp =  Shapefile.Handle(joinpath(current_directory,"data_geostats_julia/boundary1.shp")).shapes

# Define a reducer function (e.g., to sum values within each cell)
reducer(cell_values) = sum(cell_values)

rasterized_krig = rasterize(shape, fill=Œ©.logzinc, reducer = reducer, size=(100, 100))
Plots.plot(rasterized_krig)
```

    Burning each geometry to a BitArray slice...   0%|                                                  |  ETA: 0:48:28

    Burning each geometry to a BitArray slice... 100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| Time: 0:00:00

    Reducing...   4%|‚ñà‚ñà                                                |  ETA: 0:00:02

    Reducing...  47%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñå                          |  ETA: 0:00:00

    Reducing...  89%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñå     |  ETA: 0:00:00

    Reducing... 100%|‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà| Time: 0:00:00

![](R-Julia-Geostats-v-fix-version/figure-markdown_strict/cell-8-output-7.png)

```{r, eval = FALSE}
#Crop 
masked = mask(rasterized_krig,with=grid_shp)
Plots.plot(masked, title = "Krigeage logzinc")
```

![](R-Julia-Geostats-v-fix-version/figure-markdown_strict/cell-9-output-1.png)

# 4 - Comparaison

<table style="width:99%;">
<colgroup>
<col style="width: 27%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="header">
<th>Package</th>
<th>R : gstat</th>
<th>R : GeoModels</th>
<th>Julia : GeoStats</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Type de donn√©es d‚Äôentr√©e</td>
<td>sp, sf</td>
<td>matrices, vecteurs</td>
<td><p>dataframes</p>
<p>Coordon√©es de type CartesianGrid</p>
<p>Inconv√©nient : peu de documentation - difficile √† prendre en
main</p></td>
</tr>
<tr class="even">
<td>Documentation</td>
<td>CRAN</td>
<td><p>CRAN</p>
<p>https://vmoprojs.github.io/GeoModels-page/</p></td>
<td><p><a href="https://github.com/JuliaEarth/GeoStats.jl"
class="uri">https://github.com/JuliaEarth/GeoStats.jl</a></p>
<p>https://juliapackages.com/p/geostats</p></td>
</tr>
<tr class="odd">
<td>Estimation de param√®tres du variogramme</td>
<td><p>Moindres carr√©s sur variogramme empirique</p>
<p>1 mod√®le √† la fois au choix</p></td>
<td><p>Vraisemblance composite sur les donn√©es</p>
<p>1 mod√®le √† la fois</p>
<p>Param√®tres fixes ou variables au choix</p></td>
<td><p>Moindres carr√©s sur le variogramme empirique</p>
<p>Tous les mod√®les disponibles √† la fois</p></td>
</tr>
<tr class="even">
<td>Vitesse d‚Äôex√©cution - estimation du variogramme empirique</td>
<td>0.05s</td>
<td>0.07s</td>
<td>0.012s</td>
</tr>
<tr class="odd">
<td>Vitesse d‚Äôex√©cution - estimation du variogramme th√©orique</td>
<td>0.04s</td>
<td>1.15s</td>
<td>0.05s (TOUS LES MODELES)</td>
</tr>
<tr class="even">
<td>Vitesse d‚Äôex√©cution - krigeage</td>
<td>0.42s</td>
<td>0.87s</td>
<td><p>0.08s (Kriging)</p>
<p>10.6s (solve)</p></td>
</tr>
</tbody>
</table>
